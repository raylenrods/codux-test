"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppDefDriver = void 0;
const commonjs_1 = require("@file-services/commonjs");
const memory_1 = require("@file-services/memory");
const resolve_1 = require("@file-services/resolve");
const path_1 = __importDefault(require("@file-services/path"));
class AppDefDriver {
    constructor(options) {
        this.options = options;
        this.dirListeners = [];
        this.manifestListeners = new Set();
        this.fileListeners = {};
        this.exportsListeners = {};
        this.lastManifest = null;
        this.fsApi = {
            appDefFilePath: this.options.appDefFilePath || '/app-def.ts',
            projectPath: this.options.projectPath || '/',
            path: path_1.default.posix,
            watchDirectory: (dirPath, cb) => {
                const listener = {
                    cb,
                    dirPath,
                };
                this.dirListeners.push(listener);
                return {
                    stop: () => {
                        this.dirListeners = this.dirListeners.filter((l) => l !== listener);
                    },
                    filePaths: Promise.resolve(this.listNestedPaths(dirPath)),
                };
            },
            watchFile: (filePath, cb) => {
                var _a;
                const listeners = this.fileListeners[filePath] || new Set();
                listeners.add(cb);
                this.fileListeners[filePath] = listeners;
                return {
                    stop: () => {
                        listeners.delete(cb);
                    },
                    contents: Promise.resolve((_a = this.fs.readFileSync(filePath, { encoding: 'utf8' })) !== null && _a !== void 0 ? _a : null),
                };
            },
            watchFileExports: (filePath, cb) => {
                const listeners = this.exportsListeners[filePath] || new Set();
                listeners.add(cb);
                this.exportsListeners[filePath] = listeners;
                let moduleExports = [];
                try {
                    const module = this.moduleSystem.requireModule(filePath);
                    moduleExports = Object.keys(module);
                }
                catch (e) {
                    const errMsg = e instanceof Error ? e.message : String(e);
                    throw new Error(`error requiring module ${filePath}: ${errMsg}`);
                }
                return {
                    stop: () => {
                        listeners.delete(cb);
                    },
                    exportNames: Promise.resolve(moduleExports),
                };
            },
        };
        this.importModule = (filePath, onModuleChange) => {
            const requireModule = () => {
                let module, errorMessage;
                try {
                    module = this.moduleSystem.requireModule(filePath);
                }
                catch (error) {
                    errorMessage = error instanceof Error ? error.message : String(error);
                }
                return { module, errorMessage };
            };
            const { stop } = this.fsApi.watchFile(filePath, () => {
                this.moduleSystem.moduleCache.delete(filePath);
                const { module, errorMessage } = requireModule();
                onModuleChange === null || onModuleChange === void 0 ? void 0 : onModuleChange({
                    results: module || null,
                    status: errorMessage ? 'invalid' : 'ready',
                    errorMessage,
                });
            });
            const { module, errorMessage } = requireModule();
            return {
                moduleResults: Promise.resolve({
                    status: errorMessage ? 'invalid' : 'ready',
                    results: module || null,
                    errorMessage,
                }),
                dispose() {
                    stop();
                },
            };
        };
        this.fs = (0, memory_1.createMemoryFs)(options.initialFiles);
        const resolver = (0, resolve_1.createRequestResolver)({ fs: this.fs });
        this.moduleSystem = (0, commonjs_1.createBaseCjsModuleSystem)({
            dirname: this.fs.dirname,
            readFileSync: (filePath) => {
                const fileContents = this.fs.readFileSync(filePath, { encoding: 'utf8' });
                if (typeof fileContents !== 'string') {
                    throw new Error(`No content for: ${filePath}`);
                }
                return fileContents;
            },
            resolveFrom(contextPath, request) {
                if (options.evaluatedNodeModules[request]) {
                    return request;
                }
                const resolved = resolver(contextPath, request);
                return resolved.resolvedFile;
            },
            globals: {},
        });
        for (const [packageSpecifier, module] of Object.entries(options.evaluatedNodeModules)) {
            this.moduleSystem.moduleCache.set(packageSpecifier, {
                id: '',
                filename: this.fs.join(packageSpecifier, 'pre-evaluated.js'),
                exports: module,
                children: [],
            });
        }
    }
    async init() {
        const { dispose, manifest } = await this.options.app.prepareApp({
            fsApi: this.fsApi,
            onManifestUpdate: (manifest) => {
                this.lastManifest = manifest;
                this.dispatchManifestUpdate();
            },
        });
        this.lastManifest = manifest;
        this.disposeApp = dispose;
        return manifest;
    }
    addOrUpdateFile(filePath, contents) {
        const existingFile = !!this.fs.existsSync(filePath);
        this.fs.writeFileSync(filePath, contents);
        if (!existingFile) {
            for (const listener of this.dirListeners) {
                if (filePath.startsWith(listener.dirPath)) {
                    listener.cb(this.listNestedPaths(listener.dirPath));
                }
            }
        }
        else {
            this.moduleSystem.moduleCache.delete(filePath);
        }
        const fileListeners = this.fileListeners[filePath];
        if (fileListeners) {
            for (const listener of fileListeners) {
                listener(contents);
            }
        }
        const exportsListeners = this.exportsListeners[filePath];
        if (exportsListeners) {
            let moduleExports = [];
            try {
                const module = this.moduleSystem.requireModule(filePath);
                moduleExports = Object.keys(module);
            }
            catch (e) {
                // unable to require module - no exports
                const errMsg = e instanceof Error ? e.message : String(e);
                throw new Error(`error requiring module ${filePath}: ${errMsg}`);
            }
            for (const listener of exportsListeners) {
                listener(moduleExports);
            }
        }
    }
    getManifest() {
        return this.lastManifest;
    }
    getNewPageInfo(requestedURI) {
        return this.options.app.getNewPageInfo({
            fsApi: this.fsApi,
            manifest: this.lastManifest,
            requestedURI,
        });
    }
    getMovePageInfo(movedFilePath, requestedURI) {
        return this.options.app.getMovePageInfo({
            fsApi: this.fsApi,
            manifest: this.lastManifest,
            requestedURI,
            movedFilePath,
        });
    }
    addManifestListener(cb) {
        this.manifestListeners.add(cb);
    }
    removeManifestListener(cb) {
        this.manifestListeners.delete(cb);
    }
    dispatchManifestUpdate() {
        for (const listener of this.manifestListeners) {
            listener(this.lastManifest);
        }
    }
    async render({ uri = '/', testAutoRerenderOnManifestUpdate, } = {}) {
        const { app } = this.options;
        const { fsApi, importModule } = this;
        if (!app.callServerMethod) {
            throw new Error('app.callServerMethod is not defined');
        }
        const container = document.body.appendChild(document.createElement('div'));
        const createProps = (uri) => ({
            callServerMethod(filePath, methodName, args) {
                return app.callServerMethod({
                    fsApi,
                    importModule,
                }, filePath, methodName, args);
            },
            importModule: this.importModule,
            manifest: this.lastManifest,
            onCaughtError() {
                /**/
            },
            setUri(_uri) {
                // ToDo: implement
            },
            uri,
        });
        const unmount = await app.render(container, createProps(uri));
        let lastUri = uri;
        const rerender = ({ uri = '/' } = {}) => {
            lastUri = uri;
            return app.render(container, createProps(uri));
        };
        const manifestListener = () => {
            void rerender({ uri: lastUri });
        };
        if (testAutoRerenderOnManifestUpdate !== false) {
            this.addManifestListener(manifestListener);
        }
        return {
            dispose: () => {
                unmount();
                container.remove();
                this.removeManifestListener(manifestListener);
            },
            container,
            rerender,
        };
    }
    dispose() {
        var _a;
        (_a = this.disposeApp) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    listNestedPaths(dirPath) {
        const nestedPaths = [];
        for (const file of this.fs.readdirSync(dirPath)) {
            const filePath = path_1.default.join(dirPath, file);
            if (this.fs.statSync(filePath).isDirectory()) {
                nestedPaths.push(...this.listNestedPaths(filePath));
            }
            else {
                nestedPaths.push(filePath);
            }
        }
        return nestedPaths;
    }
}
exports.AppDefDriver = AppDefDriver;
//# sourceMappingURL=index.js.map