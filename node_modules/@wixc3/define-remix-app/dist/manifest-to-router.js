"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileToRoute = exports.clearLoadedModules = exports.manifestToRouter = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const remix_app_utils_1 = require("./remix-app-utils");
const testing_1 = require("@remix-run/testing");
const react_1 = require("react");
const react_2 = require("@remix-run/react");
const handle_proxy_1 = require("./handle-proxy");
const links_proxy_1 = require("./links-proxy");
const defer_1 = require("./defer");
const manifestToRouter = (manifest, navigation, requireModule, onCaughtError, callServerMethod) => {
    const routerData = manifest.extraData;
    const rootFilePath = routerData.file;
    const rootExports = routerData.exportNames;
    if (!rootFilePath || !rootExports) {
        return {
            Router: (0, testing_1.createRemixStub)([]),
            navigate(path) {
                navigation.navigate(path);
            },
        };
    }
    const rootRoute = (0, exports.fileToRoute)('/', rootFilePath, rootExports, requireModule, onCaughtError, true, callServerMethod, navigation);
    const addChildren = (route, children) => {
        route.children = children.map((child) => {
            const childRoute = (0, exports.fileToRoute)(child.path, child.file, child.exportNames, requireModule, onCaughtError, false, callServerMethod, navigation);
            addChildren(childRoute, child.children);
            return childRoute;
        });
    };
    addChildren(rootRoute, routerData.children);
    const Router = (0, testing_1.createRemixStub)([rootRoute]);
    return {
        Router,
    };
};
exports.manifestToRouter = manifestToRouter;
const loadedModules = new Map();
const clearLoadedModules = () => {
    loadedModules.clear();
};
exports.clearLoadedModules = clearLoadedModules;
const fileToRoute = (uri, filePath, exportNames, requireModule, onCaughtError, isRootFile = false, callServerMethod, navigation) => {
    const key = filePath + '#' + exportNames.join(',');
    let module = loadedModules.get(key);
    if (!module) {
        module = nonMemoFileToRoute(uri, filePath, exportNames, requireModule, onCaughtError, isRootFile, callServerMethod, navigation);
        loadedModules.set(key, module);
    }
    return module;
};
exports.fileToRoute = fileToRoute;
function RootComp({ module, navigation, filePath, }) {
    const revalidator = (0, react_2.useRevalidator)();
    const currentModule = useDispatcher(module, (0, react_1.useCallback)(() => {
        // invalidates loader data
        revalidator.revalidate();
    }, [revalidator]));
    const { pathname, search = '', hash = '' } = (0, react_2.useLocation)();
    const uri = `${pathname}${search}${hash}`;
    navigation.setNavigateFunction((0, react_2.useNavigate)());
    (0, react_1.useEffect)(() => {
        if (uri.slice(1) !== navigation.getCurrentPath()) {
            navigation.onPreviewNavigation(uri.slice(1));
        }
    }, [uri, navigation]);
    if (currentModule.errorMessage) {
        return (0, jsx_runtime_1.jsx)("div", { children: currentModule.errorMessage });
    }
    const moduleAsExpected = currentModule.results;
    const Page = moduleAsExpected.default;
    if (!Page) {
        return (0, jsx_runtime_1.jsxs)("div", { children: ["default export not found at ", filePath] });
    }
    if (moduleAsExpected.Layout) {
        return ((0, jsx_runtime_1.jsx)(moduleAsExpected.Layout, { children: (0, jsx_runtime_1.jsx)(Page, {}) }));
    }
    return (0, jsx_runtime_1.jsx)(Page, {});
}
function PageComp({ module, filePath }) {
    const revalidator = (0, react_2.useRevalidator)();
    const currentModule = useDispatcher(module, (0, react_1.useCallback)(() => {
        // invalidates loader data
        revalidator.revalidate();
    }, [revalidator]));
    const location = (0, react_2.useLocation)();
    if (currentModule.errorMessage) {
        return (0, jsx_runtime_1.jsx)("div", { children: currentModule.errorMessage });
    }
    const moduleAsExpected = currentModule.results;
    const Page = moduleAsExpected.default;
    if (!Page) {
        return (0, jsx_runtime_1.jsxs)("div", { children: ["default export not found at ", filePath] });
    }
    return (0, jsx_runtime_1.jsx)(Page, {}, location.pathname);
}
function HydrateFallbackComp({ module, filePath }) {
    const currentModule = useDispatcher(module);
    const location = (0, react_2.useLocation)();
    if (currentModule.errorMessage) {
        return (0, jsx_runtime_1.jsx)("div", { children: currentModule.errorMessage });
    }
    const moduleAsExpected = currentModule.results;
    const HydrateFallbackComp = moduleAsExpected.HydrateFallbackComp;
    if (!HydrateFallbackComp) {
        return (0, jsx_runtime_1.jsxs)("div", { children: ["HydrateFallbackComp export not found at ", filePath] });
    }
    return (0, jsx_runtime_1.jsx)(HydrateFallbackComp, {}, location.pathname);
}
function nonMemoFileToRoute(uri, filePath, exportNames, requireModule, onCaughtError, isRootFile = false, callServerMethod, navigation) {
    const { handle, setHandle } = (0, handle_proxy_1.createHandleProxy)();
    const { linksWrapper, setLinks } = (0, links_proxy_1.createLinksProxy)();
    const importModuleAndUpdate = (filePath, cb) => {
        const { moduleResults, dispose } = requireModule(filePath, (newResults) => {
            setHandle(newResults.results.handle);
            const linksFunction = newResults.results.links;
            if (linksFunction) {
                setLinks(linksFunction);
            }
            cb === null || cb === void 0 ? void 0 : cb(newResults);
        });
        const results = moduleResults.then((res) => {
            if (res.status === 'ready') {
                setHandle(res.results.handle);
                const linksFunction = res.results.links;
                if (linksFunction) {
                    setLinks(linksFunction);
                }
            }
            return res;
        });
        return { moduleResults: results, dispose };
    };
    const Component = (0, react_1.lazy)(async () => {
        let updateModule = undefined;
        const { moduleResults } = importModuleAndUpdate(filePath, (newResults) => {
            updateModule === null || updateModule === void 0 ? void 0 : updateModule(newResults);
        });
        const initialyLoadedModule = await moduleResults;
        const dispatcher = createDispatcher(initialyLoadedModule);
        updateModule = (newModule) => dispatcher.setState(newModule);
        if (isRootFile) {
            return {
                default: () => {
                    return ((0, jsx_runtime_1.jsx)(react_1.Suspense, { children: (0, jsx_runtime_1.jsx)(RootComp, { navigation: navigation, module: dispatcher, filePath: filePath }) }));
                },
            };
        }
        return {
            default: () => {
                return (0, jsx_runtime_1.jsx)(PageComp, { module: dispatcher, filePath: filePath });
            },
        };
    });
    const serverLoaderExportName = exportNames.includes('coduxLoader') ? 'coduxLoader' : 'loader';
    const serverLoader = async ({ params, request }) => {
        const res = await callServerMethod(filePath, serverLoaderExportName, [
            { params, request: await (0, remix_app_utils_1.serializeRequest)(request) },
        ]);
        if ((0, remix_app_utils_1.isSerializedResponse)(res)) {
            const desRes = (0, remix_app_utils_1.deserializeResponse)(res);
            return (0, defer_1.isDeferredResult)(desRes) ? await (0, defer_1.deserializeDeferredResult)(desRes) : desRes;
        }
        else {
            return res;
        }
    };
    const serverActionExportName = exportNames.includes('coduxAction') ? 'coduxAction' : 'action';
    const serverAction = async ({ params, request }) => {
        const res = await callServerMethod(filePath, serverActionExportName, [
            { params, request: await (0, remix_app_utils_1.serializeRequest)(request) },
        ]);
        const desRes = (0, remix_app_utils_1.deserializeResponse)(res);
        return (0, defer_1.isDeferredResult)(desRes) ? (0, defer_1.deserializeDeferredResult)(desRes) : desRes;
    };
    const loader = exportNames.includes('clientLoader')
        ? async ({ params, request }) => {
            var _a, _b;
            const lastResults = { current: { status: 'loading', results: null } };
            const { moduleResults } = importModuleAndUpdate(filePath, (updated) => {
                lastResults.current = updated;
            });
            const initialyLoadedModule = await moduleResults;
            lastResults.current = initialyLoadedModule;
            if (initialyLoadedModule.status !== 'ready') {
                throw new Error(initialyLoadedModule.errorMessage);
            }
            return (_b = (_a = lastResults.current.results).clientLoader) === null || _b === void 0 ? void 0 : _b.call(_a, {
                params,
                request,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                serverLoader: () => serverLoader({ params, request, context: {} }),
            });
        }
        : exportNames.includes(serverLoaderExportName)
            ? serverLoader
            : undefined;
    if (loader && !exportNames.includes(serverLoaderExportName)) {
        loader.hydrate = true;
    }
    const ErrorBoundary = exportNames.includes('ErrorBoundary')
        ? (0, react_1.lazy)(async () => {
            const { moduleResults } = requireModule(filePath);
            const { results } = await moduleResults;
            const routeModule = results;
            return {
                default: () => ((0, jsx_runtime_1.jsx)(ErrorPage, { filePath: filePath, routeModule: routeModule, onCaughtError: onCaughtError, navigation: navigation, isRootFile: isRootFile })),
            };
        })
        : undefined;
    const action = exportNames.includes('clientAction')
        ? async ({ params, request }) => {
            var _a, _b;
            const lastResults = { current: { status: 'loading', results: null } };
            const { moduleResults } = importModuleAndUpdate(filePath, (updated) => {
                lastResults.current = updated;
            });
            const initialyLoadedModule = await moduleResults;
            lastResults.current = initialyLoadedModule;
            if (initialyLoadedModule.status !== 'ready') {
                throw new Error(initialyLoadedModule.errorMessage);
            }
            return (_b = (_a = lastResults.current.results).clientAction) === null || _b === void 0 ? void 0 : _b.call(_a, {
                params,
                request,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                serverAction: () => serverAction({ params, request, context: {} }),
            });
        }
        : exportNames.includes(serverActionExportName)
            ? serverAction
            : undefined;
    const HydrateFallback = exportNames.includes('HydrateFallback')
        ? (0, react_1.lazy)(async () => {
            let updateModule = undefined;
            const { moduleResults } = importModuleAndUpdate(filePath, (newResults) => {
                updateModule === null || updateModule === void 0 ? void 0 : updateModule(newResults);
            });
            const initialyLoadedModule = await moduleResults;
            const dispatcher = createDispatcher(initialyLoadedModule);
            updateModule = (newModule) => dispatcher.setState(newModule);
            return {
                default: () => {
                    return (0, jsx_runtime_1.jsx)(HydrateFallbackComp, { module: dispatcher, filePath: filePath });
                },
            };
        })
        : undefined;
    const links = exportNames.includes('links') ? linksWrapper : undefined;
    return { Component, loader, ErrorBoundary, action, path: uri, handle, HydrateFallback, links };
}
function createDispatcher(value) {
    const listeners = new Set();
    return {
        getState: () => value,
        setState: (newValue) => {
            value = newValue;
            listeners.forEach((listener) => listener(value));
        },
        subscribe: (listener) => {
            listeners.add(listener);
            return () => {
                listeners.delete(listener);
            };
        },
    };
}
function useDispatcher(dispatcher, onChange) {
    const [state, setState] = (0, react_1.useState)(dispatcher.getState());
    (0, react_1.useEffect)(() => {
        return dispatcher.subscribe((newValue) => {
            setState(newValue);
            onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
        });
    }, [dispatcher, onChange]);
    return state;
}
function ErrorPage({ navigation, routeModule, filePath, onCaughtError, isRootFile, }) {
    navigation.setNavigateFunction((0, react_2.useNavigate)());
    (0, react_1.useEffect)(() => {
        onCaughtError({ filePath, exportName: 'ErrorBoundary' });
    }, [filePath, onCaughtError]);
    const errorContent = routeModule.ErrorBoundary ? ((0, jsx_runtime_1.jsx)(routeModule.ErrorBoundary, {})) : ((0, jsx_runtime_1.jsxs)("div", { children: ["error boundary not found at ", filePath] }));
    if (isRootFile && routeModule.Layout) {
        const Layout = routeModule.Layout;
        return (0, jsx_runtime_1.jsx)(Layout, { children: errorContent });
    }
    else {
        return errorContent;
    }
}
//# sourceMappingURL=manifest-to-router.js.map