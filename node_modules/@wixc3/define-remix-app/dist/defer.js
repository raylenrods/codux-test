"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryToSerializeDeferredData = tryToSerializeDeferredData;
exports.isDeferredResult = isDeferredResult;
exports.deserializeDeferredResult = deserializeDeferredResult;
const router_1 = require("@remix-run/router");
const node_1 = require("@remix-run/node");
const remix_app_utils_1 = require("./remix-app-utils");
async function tryToSerializeDeferredData(res) {
    if (!(0, router_1.isDeferredData)(res)) {
        return;
    }
    await res.resolveData(new AbortController().signal);
    return (0, remix_app_utils_1.serializeResponse)((0, node_1.json)({
        __deferred: true,
        data: Object.entries(res.data).reduce((acc, [key, value]) => {
            if (res.deferredKeys.includes(key) && isDeferredPromise(value)) {
                acc[key] = value._data ? value._data : undefined;
            }
            else {
                acc[key] = value;
            }
            return acc;
        }, {}),
        deferredKeys: res.deferredKeys.reduce((acc, key) => {
            const promise = res.data[key];
            if (promise._data) {
                acc[key] = { status: 'fulfilled' };
            }
            else {
                acc[key] = { status: 'rejected', reason: String(promise._error) };
            }
            return acc;
        }, {}),
    }), [{ key: remix_app_utils_1.CoduxDeferredHeaderKey, value: 'true' }]);
}
function isDeferredResult(response) {
    return response.headers.has(remix_app_utils_1.CoduxDeferredHeaderKey);
}
async function deserializeDeferredResult(response) {
    const parsedResponse = (await tryDecodeResponseJsonValue(response));
    if (!(parsedResponse === null || parsedResponse === void 0 ? void 0 : parsedResponse.data) || !parsedResponse.deferredKeys) {
        return {};
    }
    const { data, deferredKeys } = parsedResponse;
    const result = Object.assign({}, data);
    for (const [key, x] of Object.entries(deferredKeys)) {
        if (x.status === 'fulfilled') {
            result[key] = Promise.resolve(result[key]);
        }
        else {
            const rejectedDeferred = Promise.reject(new Error(String(x.reason)));
            rejectedDeferred.catch(() => { });
            result[key] = rejectedDeferred;
        }
    }
    return result;
}
async function tryDecodeResponseJsonValue(response) {
    var _a;
    const reader = (_a = response.clone().body) === null || _a === void 0 ? void 0 : _a.getReader();
    const td = new TextDecoder('utf-8', {});
    let text = '';
    while (reader && true) {
        const { value, done } = (await reader.read());
        text += td.decode(value);
        if (done) {
            break;
        }
    }
    try {
        return JSON.parse(text);
    }
    catch (_b) {
        /**/
    }
    return;
}
function isDeferredPromise(value) {
    return (value instanceof Promise &&
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
        (value._data !== undefined || value._error !== undefined));
}
//# sourceMappingURL=defer.js.map