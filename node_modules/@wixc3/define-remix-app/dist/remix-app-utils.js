"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoduxDeferredHeaderKey = exports.routePathId = exports.anErrorRoute = exports.aRoute = exports.routePartsToRoutePath = void 0;
exports.filePathToReadableUri = filePathToReadableUri;
exports.readableUriToFilePath = readableUriToFilePath;
exports.filePathToURLParts = filePathToURLParts;
exports.filePathToLayoutMatching = filePathToLayoutMatching;
exports.urlPartsToLayoutMatching = urlPartsToLayoutMatching;
exports.filePathToRouteId = filePathToRouteId;
exports.pathToRemixRouterUrl = pathToRemixRouterUrl;
exports.capitalizeFirstLetter = capitalizeFirstLetter;
exports.toCamelCase = toCamelCase;
exports.chooseOverridingPath = chooseOverridingPath;
exports.serializeRequest = serializeRequest;
exports.deserializeRequest = deserializeRequest;
exports.serializeResponse = serializeResponse;
exports.isSerializedResponse = isSerializedResponse;
exports.deserializeResponse = deserializeResponse;
const routePartsToRoutePath = (routeParts) => {
    return routeParts
        .map((p) => {
        if (p === '$') {
            return {
                kind: 'dynamic',
                name: '$',
                isCatchAll: true,
            };
        }
        if (p.startsWith('($') && p.endsWith(')')) {
            return {
                kind: 'dynamic',
                name: p.slice(2, p.length - 1),
                isOptional: true,
            };
        }
        if (p.startsWith('$')) {
            return {
                kind: 'dynamic',
                name: p.slice(1, p.length),
            };
        }
        if (p.startsWith('_')) {
            return null;
        }
        if (p.endsWith('_')) {
            return {
                kind: 'static',
                text: p.slice(0, p.length - 1),
            };
        }
        return {
            kind: 'static',
            text: p,
        };
    })
        .filter((p) => !!p);
};
exports.routePartsToRoutePath = routePartsToRoutePath;
function filePathToReadableUri(filePathInRouteDir, path) {
    const parts = filePathToURLParts(filePathInRouteDir, path);
    if (parts.length === 1 && parts[0] === '_index') {
        return '';
    }
    return parts.join('/');
}
function readableUriToFilePath(readableUri, path, routeDir, routingPattern) {
    const pageFileName = readableUri.replace(/\//g, '.');
    return routingPattern === 'folder(route)'
        ? path.join(routeDir, pageFileName, 'route.tsx')
        : routingPattern === 'folder(index)'
            ? path.join(routeDir, pageFileName, 'index.tsx')
            : path.join(routeDir, pageFileName + '.tsx');
}
const aRoute = (routeDirPath, path, parentLayouts, pageModule, pathApi, hasGetStaticRoutes) => ({
    path,
    pageModule,
    pageExportName: 'default',
    parentLayouts,
    pathString: filePathToReadableUri(pageModule.slice(routeDirPath.length + 1), pathApi) || '',
    hasGetStaticRoutes,
    extraData: undefined,
});
exports.aRoute = aRoute;
const anErrorRoute = (routeDirPath, path, pageModule, parentLayouts, pathApi) => ({
    path,
    pageModule,
    pageExportName: 'ErrorBoundary',
    parentLayouts,
    pathString: filePathToReadableUri(pageModule.slice(routeDirPath.length + 1), pathApi) || '',
    extraData: undefined,
    hasGetStaticRoutes: false,
});
exports.anErrorRoute = anErrorRoute;
function filePathToURLParts(filePathInRouteDir, path) {
    const dirStructure = filePathInRouteDir.split(path.sep);
    if (dirStructure.length === 1) {
        const baseName = path.basename(filePathInRouteDir);
        const parts = baseName.split('.');
        return parts.slice(0, parts.length - 1);
    }
    if (dirStructure.length === 2) {
        if (dirStructure[1] === 'route.tsx' || dirStructure[1] === 'index.tsx') {
            return dirStructure[0].split('.');
        }
    }
    return [];
}
function filePathToLayoutMatching(filePathInRouteDir, path) {
    const parts = filePathToURLParts(filePathInRouteDir, path);
    return urlPartsToLayoutMatching(parts);
}
function urlPartsToLayoutMatching(parts) {
    if (parts.length === 0 || (parts.length === 1 && parts[0] === '_index')) {
        return [];
    }
    if (parts[0].startsWith('_')) {
        // file uses or is a named layout, wo we sould only return the first part and any adjacant parts the start with _
        const layoutParts = [parts[0]];
        let i = 1;
        while (i < parts.length && parts[i].startsWith('_')) {
            layoutParts.push(parts[i]);
            i++;
        }
    }
    // file does not use a named layout, we should return all the parts
    return parts;
}
/**
 * creates a routeId identical to remix routeIDs from a file path
 * @param appDir the root directory of the app
 * @param filePath the full path of the file
 * @returns
 */
function filePathToRouteId(appDir, filePath) {
    return filePath
        .slice(appDir.length + 1)
        .split('.')
        .slice(0, -1)
        .join('/');
}
/**
 * converts a path to a remix router url
 * @param path
 * @returns
 */
function pathToRemixRouterUrl(path) {
    return ('/' +
        path
            .map((part) => {
            if (part.kind === 'static') {
                return part.text;
            }
            return `:${part.name}`;
        })
            .join('/'));
}
/**
 * creates a unique id for a route path for checing collisions
 * @param path
 * @returns
 */
const routePathId = (path) => {
    return path
        .map((part) => {
        if (part.kind === 'static') {
            return part.text;
        }
        return `$$$`;
    })
        .join('/');
};
exports.routePathId = routePathId;
function capitalizeFirstLetter(val) {
    return val.length === 0 ? val : val.charAt(0).toUpperCase() + val.slice(1);
}
function toCamelCase(str) {
    const words = str
        .split('.')
        .map((word, index) => (index > 0 ? capitalizeFirstLetter(word.toLowerCase()) : word.toLowerCase()));
    return words.join('');
}
/**
 * remix allows many files to define the same route, this function chooses the file that should be used
 * 1. prefers _index files over layout files i.e. product._index.tsx over product.tsx
 * 2. prefers /index.tsx over normal files i.e. product/index.tsx over product.tsx
 * 3. prefers /route.tsx over /index.tsx i.e. product/route.tsx over product/index.tsx
 * 4. prefers name_ files over name files i.e. abc_.product.tsx over abc.product.tsx
 * since in all cases it seems to return the longer file name, we can just return the longer file name
 */
function chooseOverridingPath(fileA, fileB) {
    return fileA.length > fileB.length ? fileA : fileB;
}
async function serializeRequest(request) {
    const formData = request.method === 'POST' ? getFormData(await request.formData()) : {};
    return {
        url: request.url,
        method: request.method,
        headers: getHeaders(request),
        formData,
    };
}
function deserializeRequest(request) {
    const headers = new Headers();
    request.headers.forEach(({ key, value }) => {
        headers.set(key, value);
    });
    const r = new Request(request.url, { method: request.method, headers });
    r.formData = () => {
        const formData = new FormData();
        request.formData.forEach(({ key, value }) => {
            formData.append(key, value);
        });
        return Promise.resolve(formData);
    };
    return r;
}
function getHeaders(from) {
    const headers = [];
    from.headers.forEach((value, key) => {
        headers.push({ key, value });
    });
    return headers;
}
function getFormData(formData) {
    const entries = [];
    formData.forEach((value, key) => {
        entries.push({ key, value });
    });
    return entries;
}
async function serializeResponse(response, headers) {
    var _a;
    const reader = (_a = response.body) === null || _a === void 0 ? void 0 : _a.getReader();
    let body = null;
    if (reader) {
        const streamRes = await reader.read();
        body = new TextDecoder().decode(streamRes.value);
    }
    return {
        _serializedResponse: true,
        status: response.status,
        statusText: response.statusText,
        headers: [...getHeaders(response), ...(headers || [])],
        body,
    };
}
function isSerializedResponse(response) {
    return (response === null || response === void 0 ? void 0 : response._serializedResponse) === true;
}
exports.CoduxDeferredHeaderKey = 'codux-remix-deferred';
function deserializeResponse(response) {
    var _a;
    const headers = new Headers();
    (_a = response.headers) === null || _a === void 0 ? void 0 : _a.forEach(({ key, value }) => {
        headers.set(key, value);
    });
    return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers,
    });
}
//# sourceMappingURL=remix-app-utils.js.map