"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INVALID_MSGS = void 0;
exports.default = defineRemixApp;
const jsx_runtime_1 = require("react/jsx-runtime");
const app_core_1 = require("@wixc3/app-core");
const react_1 = require("react");
const remix_app_utils_1 = require("./remix-app-utils");
const manifest_to_router_1 = require("./manifest-to-router");
const content_1 = require("./content");
const page_template_1 = require("./page-template");
const navigation_1 = require("./navigation");
const defer_1 = require("./defer");
exports.INVALID_MSGS = {
    homeRouteExists: (routePath) => 'Home route already exists at ' + routePath,
    emptyName: 'page name cannot be empty',
    initialPageLetter: 'Page names must start with a letter of the alphabet',
    invalidVar: (varName) => `invalid variable name: "${varName}", page params must start with a letter or underscore and contain only letters, numbers and underscores`,
    invalidRouteChar: (param, char) => `invalid character "${char}" in page route ${param}`,
};
function defineRemixApp({ appPath, routingPattern = 'file' }) {
    let rootLayouts = [];
    let layoutMap = new Map();
    const getRouteLayouts = (filePathInRouteDir, fsApi, layouts = layoutMap) => {
        const parentLayouts = [...rootLayouts];
        const routeLayouts = (0, remix_app_utils_1.filePathToLayoutMatching)(filePathInRouteDir, fsApi.path);
        for (let i = 0; i < routeLayouts.length - 1; i++) {
            const key = routeLayouts.slice(0, i + 1).join('/');
            const layout = layouts.get(key);
            if (layout) {
                parentLayouts.push(layout);
            }
        }
        return { parentLayouts, routeLayouts };
    };
    const getNewOrMove = ({ fsApi, requestedURI, manifest, layoutMap, }) => {
        const appDir = fsApi.path.join(fsApi.path.dirname(fsApi.appDefFilePath), appPath);
        const routeDir = fsApi.path.join(appDir, 'routes');
        const varNames = new Set();
        const pageModule = (0, remix_app_utils_1.readableUriToFilePath)(requestedURI, fsApi.path, routeDir, routingPattern);
        const urlParts = (0, remix_app_utils_1.filePathToURLParts)(pageModule.slice(routeDir.length + 1), fsApi.path);
        const wantedPath = (0, remix_app_utils_1.routePartsToRoutePath)(urlParts);
        if (requestedURI.length === 0 && manifest.homeRoute) {
            return {
                isValid: false,
                errorMessage: exports.INVALID_MSGS.homeRouteExists(manifest.homeRoute.pageModule),
                pageModule: '',
                newPageSourceCode: '',
            };
        }
        const wantedPathId = (0, remix_app_utils_1.routePathId)(wantedPath);
        const existingRoute = manifest.routes.find((route) => (0, remix_app_utils_1.routePathId)(route.path) === wantedPathId);
        const pageFileName = wantedPath
            .map((part) => {
            if (part.kind === 'static') {
                return part.text;
            }
            varNames.add(part.name);
            return `$${part.name}`;
        })
            .join('.');
        const pageName = (0, remix_app_utils_1.toCamelCase)(pageFileName);
        if (!pageName && !requestedURI) {
            return {
                isValid: false,
                errorMessage: exports.INVALID_MSGS.emptyName,
                pageModule: '',
                newPageSourceCode: '',
            };
        }
        else if (!(pageName[0] || requestedURI[0]).match(/[A-Za-z]/)) {
            return {
                isValid: false,
                errorMessage: exports.INVALID_MSGS.initialPageLetter,
                pageModule: '',
                newPageSourceCode: '',
            };
        }
        if (existingRoute) {
            if (!canFilePathBeLayout(existingRoute.pageModule, fsApi) || canFilePathBeLayout(pageModule, fsApi)) {
                return {
                    isValid: false,
                    errorMessage: 'Route already exists at file path: ' + existingRoute.pageModule,
                    pageModule: existingRoute.pageModule,
                    newPageSourceCode: '',
                    newPageRoute: existingRoute,
                };
            }
        }
        const invalidVar = [...varNames].find((varName) => !varName || !varName[0].match(/[A-Za-z_]/) || !varName.match(/^[A-Za-z_0-9]+$/));
        if (invalidVar) {
            return {
                isValid: false,
                errorMessage: exports.INVALID_MSGS.invalidVar(invalidVar),
                pageModule: '',
                newPageSourceCode: '',
            };
        }
        for (const part of wantedPath) {
            if (part.kind === 'static') {
                const matchedInvalidChars = part.text.match(/[/\\:*?"'`<>|]/g);
                if (matchedInvalidChars) {
                    return {
                        isValid: false,
                        errorMessage: exports.INVALID_MSGS.invalidRouteChar(part.text, matchedInvalidChars.join('')),
                        pageModule: '',
                        newPageSourceCode: '',
                    };
                }
            }
        }
        const newPageSourceCode = (0, page_template_1.pageTemplate)(pageName, varNames);
        const { parentLayouts } = getRouteLayouts(pageModule.slice(routeDir.length + 1), fsApi, layoutMap);
        const warningMessage = parentLayouts.reduce((acc, layout) => {
            if (layout.path && layout.path !== '/') {
                const parentLayoutPath = (0, remix_app_utils_1.filePathToReadableUri)(layout.layoutModule.slice(routeDir.length + 1), fsApi.path);
                if (parentLayoutPath && requestedURI.startsWith(parentLayoutPath)) {
                    const suggestedPath = requestedURI.replace(parentLayoutPath, parentLayoutPath + '_');
                    acc = acc
                        ? acc + '\n' + (0, content_1.parentLayoutWarning)(parentLayoutPath, suggestedPath)
                        : (0, content_1.parentLayoutWarning)(parentLayoutPath, suggestedPath);
                }
            }
            return acc;
        }, undefined);
        return {
            isValid: true,
            error: '',
            warningMessage,
            newPageSourceCode,
            pageModule,
            routingPattern,
            newPageRoute: {
                pageModule,
                pageExportName: 'default',
                extraData: undefined,
                hasGetStaticRoutes: false,
                path: wantedPath,
                pathString: requestedURI,
                parentLayouts,
            },
        };
    };
    const navigation = new navigation_1.Navigation();
    return (0, app_core_1.defineApp)({
        App: ({ manifest, importModule, setUri, uri, onCaughtError, callServerMethod, }) => {
            navigation.setOnPreviewNavigate(setUri);
            const { Router } = (0, react_1.useMemo)(() => (0, manifest_to_router_1.manifestToRouter)(manifest, navigation, importModule, onCaughtError, callServerMethod), [manifest, importModule, onCaughtError, callServerMethod]);
            (0, react_1.useEffect)(() => {
                return manifest_to_router_1.clearLoadedModules;
            }, []);
            (0, react_1.useEffect)(() => {
                navigation.navigate(uri.startsWith('/') ? uri : `/${uri}`);
            }, [uri]);
            return ((0, jsx_runtime_1.jsx)(Router, { initialEntries: [
                    {
                        pathname: '/' + uri,
                        search: '',
                    },
                ] }));
        },
        callServerMethod: async ({ importModule }, filePath, methodName, args) => {
            var _a;
            const isRequestType = ['loader', 'coduxLoader', 'action', 'coduxAction'].includes(methodName);
            if (isRequestType) {
                args = [
                    {
                        params: args[0].params,
                        request: (0, remix_app_utils_1.deserializeRequest)(args[0].request),
                    },
                ];
            }
            const loader = importModule(filePath);
            const moduleRequest = (await loader.moduleResults);
            const requestedMethod = (_a = moduleRequest.results) === null || _a === void 0 ? void 0 : _a[methodName];
            if (moduleRequest.status !== 'ready') {
                throw new Error(`Module ${filePath}: ${moduleRequest.errorMessage}`);
            }
            if (!isMethod(requestedMethod)) {
                throw new Error(`Method ${methodName} not found in ${filePath}`);
            }
            const res = await requestedMethod(...args);
            if (isRequestType && res instanceof Response) {
                return (0, remix_app_utils_1.serializeResponse)(res);
            }
            const deferredResponse = await (0, defer_1.tryToSerializeDeferredData)(res);
            if (deferredResponse) {
                return deferredResponse;
            }
            return res;
        },
        async getStaticRoutes(options, forRouteAtFilePath) {
            const results = await this.callServerMethod(options, forRouteAtFilePath, 'getStaticRoutes', []);
            if (!Array.isArray(results)) {
                throw new Error('getStaticRoutes must return an array');
            }
            if (results.some((route) => typeof route !== 'string')) {
                throw new Error('getStaticRoutes must return an array of strings');
            }
            return results;
        },
        async hasGetStaticRoutes({ fsApi }, forRouteAtFilePath) {
            const { exportNames, stop } = fsApi.watchFileExports(forRouteAtFilePath, () => { });
            const results = await exportNames;
            const hasGetStaticRoutes = results.includes('getStaticRoutes');
            stop();
            return hasGetStaticRoutes;
        },
        getNewPageInfo({ fsApi, requestedURI, manifest }) {
            return getNewOrMove({ fsApi, requestedURI, manifest, layoutMap });
        },
        getMovePageInfo({ fsApi, requestedURI, manifest, movedFilePath }) {
            const layoutsWithoutMoved = new Map([...layoutMap.entries()].filter(([_, { layoutModule }]) => layoutModule !== movedFilePath));
            layoutsWithoutMoved.delete(movedFilePath);
            return getNewOrMove({ fsApi, requestedURI, manifest, layoutMap: layoutsWithoutMoved });
        },
        async prepareApp({ fsApi, onManifestUpdate }) {
            /**
             * in remix about/route.tsx wins over about/index.tsx which in turn wins over about.tsx
             */
            const appDefDir = fsApi.path.dirname(fsApi.appDefFilePath);
            const appDir = fsApi.path.join(appDefDir, appPath);
            const rootPath = fsApi.path.join(appDir, 'root.tsx');
            const routeDir = fsApi.path.join(appDir, 'routes');
            const loadedExportState = new Map();
            const watcher = fsApi.watchDirectory(routeDir, (fileList) => {
                filePaths = fileList;
                void compute(fileList, rootPathExports).then((manifest) => {
                    onManifestUpdate(manifest);
                });
            });
            let filePaths = await watcher.filePaths;
            const loadExports = async (filePath) => {
                const state = loadedExportState.get(filePath);
                if (!state) {
                    const watcher = fsApi.watchFileExports(filePath, (exports) => {
                        const state = loadedExportState.get(filePath);
                        if (state) {
                            state.exports = exports;
                            void compute(filePaths, rootPathExports).then((manifest) => {
                                onManifestUpdate(manifest);
                            });
                        }
                    });
                    const exports = watcher.exportNames;
                    loadedExportState.set(filePath, { exports: [], stop: watcher.stop, pend: exports });
                    loadedExportState.get(filePath).exports = await exports;
                    loadedExportState.get(filePath).pend = undefined;
                    return loadedExportState.get(filePath).exports;
                }
                const pend = state === null || state === void 0 ? void 0 : state.pend;
                if (!pend) {
                    return (state === null || state === void 0 ? void 0 : state.exports) || [];
                }
                return await pend;
            };
            const rootPathExportsWatcher = fsApi.watchFileExports(rootPath, (exportNames) => {
                rootPathExports = exportNames;
                void compute(filePaths, rootPathExports).then((manifest) => {
                    onManifestUpdate(manifest);
                });
            });
            let rootPathExports = await rootPathExportsWatcher.exportNames;
            const compute = async (filesInDir, rootExportNames) => {
                const routeDirLength = routeDir.length + 1;
                const rootModuleInfo = {
                    exportNames: rootExportNames,
                    children: [],
                    file: rootPath,
                    id: 'root',
                    path: '/',
                };
                rootLayouts = [
                    {
                        id: (0, remix_app_utils_1.filePathToRouteId)(appDir, rootPath),
                        layoutExportName: 'default',
                        layoutModule: rootPath,
                        path: '/',
                        exportNames: rootExportNames,
                    },
                ];
                if (rootExportNames.includes('Layout')) {
                    rootLayouts.unshift({
                        id: 'rootLayout',
                        layoutExportName: 'Layout',
                        layoutModule: rootPath,
                        path: '/',
                        exportNames: rootExportNames,
                    });
                }
                const relevantFiles = filesInDir.filter((file) => file.endsWith('.tsx'));
                const exportNames = new Map();
                for (const file of relevantFiles) {
                    const exports = await loadExports(file);
                    exportNames.set(file, exports);
                }
                const { layouts, routes } = relevantFiles.reduce((acc, fullPath) => {
                    const pathInRoutesDir = fullPath.slice(routeDirLength);
                    const parts = (0, remix_app_utils_1.filePathToURLParts)(pathInRoutesDir, fsApi.path);
                    if (parts.length === 1 && parts[0] === '_index') {
                        if (!acc.routes.has('/')) {
                            acc.routes.set('/', {
                                file: fullPath,
                                path: [],
                                readableName: '',
                                layoutMatching: [],
                            });
                        }
                        else {
                            const rootRoute = acc.routes.get('/');
                            rootRoute.file = (0, remix_app_utils_1.chooseOverridingPath)(rootRoute.file, fullPath);
                        }
                        return acc;
                    }
                    const routePath = (0, remix_app_utils_1.routePartsToRoutePath)(parts);
                    if (!parts.find((part) => !part.startsWith('_'))) {
                        // file is a only layout
                        const layoutId = (0, remix_app_utils_1.filePathToRouteId)(appDir, fullPath);
                        acc.layouts.set(parts.join('/'), {
                            id: layoutId,
                            layoutExportName: 'default',
                            layoutModule: fullPath,
                            path: (0, remix_app_utils_1.pathToRemixRouterUrl)(routePath),
                            exportNames: exportNames.get(fullPath) || [],
                        });
                        return acc;
                    }
                    const routeUrlId = (0, remix_app_utils_1.routePathId)(routePath);
                    const routePathString = (0, remix_app_utils_1.filePathToReadableUri)(pathInRoutesDir, fsApi.path) || '';
                    if (!acc.routes.has(routeUrlId)) {
                        acc.routes.set(routeUrlId, {
                            file: fullPath,
                            path: routePath,
                            readableName: routePathString,
                            layoutMatching: (0, remix_app_utils_1.filePathToLayoutMatching)(pathInRoutesDir, fsApi.path),
                        });
                    }
                    else {
                        acc.routes.get(routeUrlId).file = (0, remix_app_utils_1.chooseOverridingPath)(acc.routes.get(routeUrlId).file, fullPath);
                    }
                    const canBeLayout = canFilePathBeLayout(fullPath, fsApi);
                    if (canBeLayout) {
                        const layoutMatching = (0, remix_app_utils_1.filePathToLayoutMatching)(pathInRoutesDir, fsApi.path);
                        const layoutId = (0, remix_app_utils_1.filePathToRouteId)(appDir, fullPath);
                        acc.layouts.set(layoutMatching.join('/'), {
                            id: layoutId,
                            layoutExportName: 'default',
                            layoutModule: fullPath,
                            path: (0, remix_app_utils_1.pathToRemixRouterUrl)(routePath),
                            exportNames: exportNames.get(fullPath) || [],
                        });
                    }
                    return acc;
                }, {
                    routes: new Map(),
                    errorRoutes: new Map(),
                    layouts: new Map(),
                    moduleExports: new Map(),
                });
                layoutMap = layouts;
                const initialManifest = {
                    routes: [],
                    errorRoutes: [],
                    extraData: rootModuleInfo,
                };
                const sortedFilesByRoute = [...routes.entries()].sort(([, a], [, b]) => a.readableName.localeCompare(b.readableName));
                if (rootExportNames.includes('ErrorBoundary')) {
                    const errorRoute = (0, remix_app_utils_1.anErrorRoute)(routeDir, [], rootPath, [], fsApi.path);
                    initialManifest.errorRoutes.push(errorRoute);
                }
                const routeInfoById = new Map();
                routeInfoById.set(rootModuleInfo.id, rootModuleInfo);
                for (const [, value] of sortedFilesByRoute) {
                    const exports = exportNames.get(value.file) || [];
                    const { parentLayouts } = getRouteLayouts(value.file.slice(routeDirLength), fsApi);
                    let parent = rootModuleInfo;
                    for (const layout of parentLayouts) {
                        if (layout.layoutModule === rootPath) {
                            continue;
                        }
                        const existingRoute = routeInfoById.get(layout.id);
                        if (!existingRoute) {
                            const layoutExports = exportNames.get(layout.layoutModule) || [];
                            const layoutRoute = {
                                id: layout.id,
                                children: [],
                                exportNames: layoutExports,
                                file: layout.layoutModule,
                                path: layout.path,
                            };
                            routeInfoById.set(layout.id, layoutRoute);
                            parent.children.push(layoutRoute);
                            parent = layoutRoute;
                        }
                        else {
                            parent = existingRoute;
                        }
                    }
                    const routeId = (0, remix_app_utils_1.filePathToRouteId)(appDir, value.file);
                    const route = {
                        id: routeId,
                        children: [],
                        exportNames: exports,
                        file: value.file,
                        path: (0, remix_app_utils_1.pathToRemixRouterUrl)(value.path),
                    };
                    routeInfoById.set(routeId, route);
                    parent.children.push(route);
                    if (value.path.length === 0) {
                        initialManifest.homeRoute = (0, remix_app_utils_1.aRoute)(routeDir, [], rootLayouts, value.file, fsApi.path, rootExportNames.includes('getStaticRoutes'));
                        if (exports.includes('ErrorBoundary')) {
                            const errorRoute = (0, remix_app_utils_1.anErrorRoute)(routeDir, value.path, value.file, rootLayouts, fsApi.path);
                            initialManifest.errorRoutes.push(errorRoute);
                        }
                    }
                    else {
                        if (exports.includes('default')) {
                            const route = (0, remix_app_utils_1.aRoute)(routeDir, value.path, parentLayouts, value.file, fsApi.path, exports.includes('getStaticRoutes'));
                            initialManifest.routes.push(route);
                            if (exports.includes('ErrorBoundary')) {
                                const errorRoute = (0, remix_app_utils_1.anErrorRoute)(routeDir, value.path, value.file, parentLayouts, fsApi.path);
                                initialManifest.errorRoutes.push(errorRoute);
                            }
                        }
                    }
                }
                return initialManifest;
            };
            return {
                dispose() {
                    watcher.stop();
                },
                manifest: await compute(filePaths, rootPathExports),
            };
        },
    });
}
const canFilePathBeLayout = (filePath, fsApi) => {
    return !filePath.endsWith('._index.tsx') && !fsApi.path.dirname(filePath).endsWith('_index');
};
function isMethod(requestedMethod) {
    return typeof requestedMethod === 'function';
}
//# sourceMappingURL=define-remix-app.js.map